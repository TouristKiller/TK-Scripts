--[[WWWWWWWWWWWWMMMMMMMMMMMMMMMWWWWMMMMMMMMMMMMWWMMWWWWMMMWNNXXXNWMWWWMMMWWWWWWWWMMMMMMMWWWWWWWWWWWW
WWWWWWWWWWWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWXOoc,'...',:lx0NMMWMMMMMMMMMMMMMMMWWWWWWWWWWWW
WWWWWWWWWWWWWMMMMTK SMARTMMMMMMMMMMMMMMMMMMMMMMMMMMNkc.             .;dXMMMMMMMMMMMMMMMMMMMWWWWWWWWW
WWWWWWWWWWWMMMMMWWMMMMMMMWWMMWMMMMMMMMMMMMMMMMMMWOl;                   'xNMMMMMMWMMMWWMMWMMWWMMWWWWW
WWWWWWWWMMMMMMMWWWMMMMMMMMWWMMMMWMMMMMMMMMMMMMMNo.      ,cc,     .:c;.   :KWWWMMMMWWMWMMMWWWWWWMWMMM
WWWWWWWWMMMMMMMWWWMMMMMMMMWWWMMWWMMWMMWWMMMMMMNo.     .oNWWNo.  ;KMMWO'   :XMWWWMMWWWWWWWWWWWMWWWMMM
WWWWWWWWMMMMMMMWWWMMMMMMWNXKKXWWMMMMMMMMMMMMMMk.      .oNWWNo.  ;KMMWO'    oWWMWKxc;,,;cxKWWWWWWMMMM
WWWWWWWWMMMMMMMMWWMMWWNkc'....,cdKWWKkollokKWWc         ,cc;.    .cl:.     ,KW0c.        ,OWWMWWMMMM
MMMMMMMMMMMMMMMWMMWWWKc          .:;.      .:d,          .'.......'.       'ko.       .:oxKWWWWWWMMM
MMMMMMMMMMMMMMMMWWMMXc                                   .lO000000d.       ..        ,OWWWMWWWMWWMMM
MMMMMMMMMMMMMMMWMMWMk.                                     'codol,.                 ,KMWWMMWWMWWMMMM
MMMMMMMMMMMMMMMMMMMMx.                                                             ,OWWWMMMWMMWWMMMM
MMMMMMMMMMMMMMMMMMWWk.  ;dooooooooooooooooooodoooooc.  .cdooo'          ;ooooo:. .lKWMMMWMMMMMMWWMMM
MMMMMMMMMMMMMMMMMMWMX; .xWWMMWWWWMMWMWWMMMMMMWWMNkc,   ,0WWMWc        'xNMWWXx. ;kNWWMWMMMMMMMMWWMMM
MMMMMMMMMMMMMMMMMMMWWx..oXKXXXKKKKKKKNWMWWWXKXKO:.     ,KMWWWc      .lKWWWWO;..xNWWMMMWMMMMMMMMWWMMM
MMMMMMMMMMMMMMMMMMWMMNo'';;;;;;;'....lNMWMK:....       ,KWWMWc     ;OWWWWKl..lKWMWWMMMMMMMMMMMMWMMMM
MMMMMMMMMMMMMMMMMMMMMMWXKKKKKKKK:    :NMWMK,           ,KWWMWc   .xNWMMNx'.,OWMWMMMMMMMMMMMMMWWWMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWc    :NMWMK,           ,KMMMWc .cKMMMW0:..dNWWMMMMMMMMMMMMMMMWWWMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWc    :NMWMK,           ,KMWMWl,OWWWMXo. '0WMWWWMMMMMMMMMMMMMMWWWMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNc    :NMWMK,           ,KMMMWXXWMMNk'   .:KWWWWWMMMMMMMMMMMMMWWMMMMM
MMMMMMMMMMMMMMMMMMMMMMWMMWMMMWMNc    :NMWMK,           ,KMMWMMMMMWd.      .xNWWWMMMMMMMMMMMMWWMMMMMM
MMMMMMMMMMMMMMMMMMMWMMWWMMWMMWMWc    :NMWMK,           ,KWWMMMMMMWKc.       ;OWWMMMMMMMMMMMMWWMMMMMM
MMMMMMMMMMMMMMMWWMWNX0O0XWMMMMMWc    :NMWMK,           ,KWMMMNXNWWWWk,       .oXWMMMMMMMMMMMWWMMMMMM
MMMMMMMMMMMMMMMMWOl;;::c:cxXMWMNc    :NMWMK,           ,KMMMWd.;OWMMMXo.       ,kWMMMMMMMMMMMMMMMMMM
MMMMMMMWWWMMMMMNd..o0KNN0x,:KWMWc    :NMWMK,           ,KMWMWc  .oXMMMW0;       .lXMWWMMMMMMMMMWWMMM
MMMMMMMWMMWWMMWx..dW0d0OxXO'cNMWc    :NMWMK,           ,KMWMWc    ,kWMMMNx.       'kNMWWMMMMMMMWWMMM
MMMMMMMMMMMWMMWo .kMWNOOWWNc'0MWc    :NMWMK,           ,KMWMWc     .cKWMMMK:       .:KWWMMMMMMMWWMMM
MWMMWWMMMMMWMMWl  oWWWNNWMMk'cNWc    :NMWMK,           ,KMWMWc       'dNMMMNk,       .dNMMWWWWWWMMMM
WWWMWWMWWWWWWMX:  .xNMWWWMMWk;:x;    :NMMMK,           ,KMMMWl         ;OWMMWKl.       :0WWWMWWWMMMM
WWWMMWWWWMWWWKc.   .:kXWMMMMWXxc,.   :NMMMK,           ,KMMMWc          .oXMWWWO;       .dXWMWWWWMMM
WWWWMMWKxxdo:.        .;cloooollc,.  .loloc.           .coool'            ,loollc.        ,dxkXWWMMM
WWWWMWW0ddddddddooddoddddddddddddddoodddddddddddddddddddddddddddddddodoooddddddddddddddddodddxKWWMMM
                                version 0.1.3 (alpha pre-release)                       
                                        date: 2024-09-11                                 
                                     author: TouristKiller                              
                         Special thanks to Dax for the idea and inspiration                                                         

CHANGELOG (start from 0.1.1):
0.1.3 2024-09-11:
- Small fixes
- Hide minimap on double click on the project timeline
- buttons to clear item name
- Checkbox for Region Render Matrix


0.1.2 2024-09-10:
- Addad a button for the LEARN BROWSER (content about markers and regions)
- Added a button to open DDP manager (if not installed it shows a button to download it)
- added a button to move all markers and regions to position of edit cursor (inspired by MPL)
- And some more buttons
- Added a progresbar to see duration of a region (inspired by X-Raym)
- Changed logo to white (more easy on the eyes ;o] )

0.1.1 2024-09-09: 
- Fixed bug with renumber buttons
- Added button to open autocolor and a button to toggle autocolor active
- Small UI changes (placements)
- Cleaned up the code

Known issues:
- Esc works only when the window is focused
- Invisible items somtimes are not persistent
- Cant empty the name input field (only when you add a space)
- Invisible items are not editeble (Persenoly I am fine with this)

Things to Do:
- Optimaliseren
- Making Invisible items more persistent, even after closing Reaper
- More Linux and MacOS support (Cant test this :o( )
- More action buttons   
- And lots more stuff!! ;o)
--------------------------------------------------------------------------------------------------]]

-- LETS GOOOOOO!
local reaper = reaper
local ctx = reaper.ImGui_CreateContext('Marker and Region Manager')
local arial_font = reaper.ImGui_CreateFont('Arial', 12)
reaper.ImGui_Attach(ctx, arial_font)


-- Bepaal het pad naar de huidige script directory
local script_path = debug.getinfo(1,'S').source:match[[^@?(.*[\/])[^\/]-$]]

-- Voeg de script directory toe aan het Lua pad
package.path = package.path .. ";" .. script_path .. "?.lua"

-- Laad de JSON module
local json = require("json")

-- Definieer de paden voor project en globale presets
local project_path = reaper.GetProjectPath("")
local global_path = reaper.GetResourcePath() .. "/Scripts/TK Scripts/TK SMART/presets/"

-- Nieuwe variabelen voor het preset systeem
--local save_preset_globally = false 
--local selectedFile = 0

-- Laad de 'save_preset_globally' instelling
local retval, value = reaper.GetProjExtState(0, "TK_SMART", "save_preset_globally")
if retval == 1 then
    save_preset_globally = (value == "true")
else
    save_preset_globally = false
end

-- Variabelen voor TK SMART LOGO
local logo_texture = nil
local logo_width, logo_height = 0, 0
local logo_loaded = false

-- Globale variabelen voor het bijhouden van bewerkingsstatus
local editing_id = nil
local editing_name = nil

local editing_time = nil
local editing_end_time = nil
local edited_times = {}
local edited_end_times = {}

local current_project = nil
local project_items = {}
local invisible_items = {}

-- Variabele voor het selecteren van markers en regions
local selected_items = {}
local item_names = {}

local show_weblink_browser = false
local show_minimap = true

-- Variabelen voor de bottem sectie
local show_rgn_playlist_checkbox = false
local show_as_gridlines = false
local show_region_marker_manager = false
local show_region_matrix_visible = false

---------------------------------------------------------------------------------
-- OVERIGE FUNTIES
--Funtie om te controleren of de escape key is ingedrukt
local function check_esc_key() 
    if reaper.ImGui_IsKeyPressed(ctx, reaper.ImGui_Key_Escape()) then
        return true
    end
    return false
end

-- Funtie voor het bepalen van de hoogte voor het child venster
local function calculate_available_height(ctx)
    local window_height = reaper.ImGui_GetWindowHeight(ctx)
    local cursor_pos_y = reaper.ImGui_GetCursorPosY(ctx)
    local bottom_section_height = 57 -- Pas dit aan op basis van de werkelijke hoogte van je onderste sectie
    return window_height - cursor_pos_y - bottom_section_height
end

-- Afbeelding inladen
local function LoadImage(file_path)
    local lice_image = reaper.JS_LICE_LoadPNG(file_path)
    if not lice_image then
      reaper.ShowConsoleMsg("Error loading image" .. file_path .. "\n")
      return nil
    end
    local width, height = reaper.JS_LICE_GetWidth(lice_image), reaper.JS_LICE_GetHeight(lice_image)
    return {image = lice_image, width = width, height = height}
  end
  
  local logo_data = nil
  
  -- Logo laden
  local function load_logo()
      if logo_data then return end  -- Voorkom het opnieuw laden als het al geladen is
      local script_path = debug.getinfo(1,'S').source:match[[^@?(.*[\/])[^\/]-$]]
      local logo_path = script_path .. "TK SMART LOGO.png"
      
      if reaper.file_exists(logo_path) then
          logo_data = LoadImage(logo_path)
        
      end
  end
  
  -- Logo weergeven
  local function display_logo(ctx)
    if logo_data then
        local display_width = 115  -- breedte van het logo
        local aspect_ratio = logo_data.width / logo_data.height
        local display_height = display_width / aspect_ratio
        
        -- Aanpassen van de positie van het logo
        reaper.ImGui_SetCursorPos(ctx, 350, 4)  -- Bijvoorbeeld: 10 pixels vanaf de linkerbovenhoek
        
        local draw_list = reaper.ImGui_GetWindowDrawList(ctx)
        local cursor_pos_x, cursor_pos_y = reaper.ImGui_GetCursorScreenPos(ctx)
        
        for y = 0, logo_data.height - 1 do
            for x = 0, logo_data.width - 1 do
                local color = reaper.JS_LICE_GetPixel(logo_data.image, x, y)
                local blue = color & 0xFF
                local green = (color >> 8) & 0xFF
                local red = (color >> 16) & 0xFF
                local alpha = (color >> 24) & 0xFF
                local imgui_color = reaper.ImGui_ColorConvertDouble4ToU32(red/255, green/255, blue/255, alpha/255)
                local scaled_x = x * (display_width / logo_data.width)
                local scaled_y = y * (display_height / logo_data.height)
                reaper.ImGui_DrawList_AddRectFilled(draw_list, cursor_pos_x + scaled_x, cursor_pos_y + scaled_y, cursor_pos_x + scaled_x + 1, cursor_pos_y + scaled_y + 1, imgui_color)
            end
        end
    else
        reaper.ImGui_Text(ctx, "TK SMART")
        reaper.ImGui_Text(ctx, "Logo not loaded")
    end
end
  

---------------------------------------------------------------------------------
-- FUNCTIONS VOOR MARKERS EN REGIONS

-- Functie om een unieke project key te genereren
local function get_project_key()
    local proj = reaper.EnumProjects(-1)
    local retval, project_path = reaper.GetProjectPath("")
    if retval and project_path and project_path ~= "" then
        return tostring(proj) .. "_" .. project_path
    else
        return tostring(proj)
    end
end

-- Functie om het pad van het onzichtbare items bestand te krijgen
local function get_invisible_items_file_path()
    local resource_path = reaper.GetResourcePath()
    return resource_path .. "/Scripts/MarkerRegionInvisibleItems.json"
end

-- Functie om het bestaan van het JSON-bestand te garanderen
local function ensure_json_file_exists()
    local file_path = get_invisible_items_file_path()
    local file = io.open(file_path, "r")
    if not file then
        file = io.open(file_path, "w")
        if file then
            file:write("[]")  -- Schrijf een lege JSON array
            file:close()
        else
            reaper.ShowMessageBox("Kan het bestand voor onzichtbare items niet aanmaken.", "Fout", 0)
        end
    else
        file:close()
    end
end

-- Functie om onzichtbare items op te slaan
local function save_invisible_items()
    local file_path = get_invisible_items_file_path()
    local file = io.open(file_path, "w")
    if file then
        file:write(json.encode(invisible_items))
        file:close()
    else
        reaper.ShowMessageBox("Kan onzichtbare items niet opslaan.", "Fout", 0)
    end
end

-- Functie om onzichtbare items te laden
local function load_invisible_items()
    local file_path = get_invisible_items_file_path()
    local file = io.open(file_path, "r")
    if file then
        local content = file:read("*all")
        file:close()
        invisible_items = json.decode(content) or {}
    else
        invisible_items = {}
    end
end

local function save_visibility_to_project()
    local project_key = get_project_key()
    local items = project_items[project_key] or {}
    local visibility_data = {}
    for _, item in ipairs(items) do
        visibility_data[tostring(item.index) .. (item.isRegion and "R" or "M")] = item.visible
    end
    local serialized = json.encode(visibility_data)
    reaper.SetProjExtState(0, "MarkerRegionManager", "VisibilityState", serialized)
end

local function load_visibility_from_project()
    local retval, serialized = reaper.GetProjExtState(0, "MarkerRegionManager", "VisibilityState")
    if retval == 1 then
        local success, visibility_data = pcall(json.decode, serialized)
        if success and type(visibility_data) == "table" then
            return visibility_data
        end
    end
    return {}
end

local last_update_time = 0
local cached_items = {}

local function get_markers_and_regions()
    local current_time = reaper.time_precise()
    local current_project_key = get_project_key()
    local visibility_data = load_visibility_from_project()

    -- Controleer of er updates zijn sinds de laatste keer
    if current_time - last_update_time < 0.1 and #cached_items > 0 then
        return cached_items
    end

    local _, num_markers, num_regions = reaper.CountProjectMarkers(0)
    local new_items = {}

    for i = 0, num_markers + num_regions - 1 do
        local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
        local visibility_key = tostring(markrgnindexnumber) .. (isrgn and "R" or "M")
        local item = {
            name = name or (isrgn and 'Region ' or 'Marker ') .. markrgnindexnumber,
            pos = pos,
            rgnend = rgnend,
            color = color,
            index = markrgnindexnumber,
            isRegion = isrgn,
            visible = visibility_data[visibility_key] ~= false,
            project_key = current_project_key
        }
        table.insert(new_items, item)
    end

    -- Voeg onzichtbare items toe
    for _, invisible_item in ipairs(invisible_items) do
        if invisible_item.project_key == current_project_key then
            local visibility_key = tostring(invisible_item.index) .. (invisible_item.isRegion and "R" or "M")
            if visibility_data[visibility_key] ~= true then
                table.insert(new_items, invisible_item)
            end
        end
    end

    -- Sorteer items
    table.sort(new_items, function(a, b)
        if a.pos == b.pos then
            return a.index < b.index
        end
        return a.pos < b.pos
    end)

    project_items[current_project_key] = new_items
    cached_items = new_items
    last_update_time = current_time

    return new_items
end

-- Pas de set_item_visibility functie aan:

local function set_item_visibility(item, visible)
    item.visible = visible
    if visible then
        if item.isRegion then
            reaper.AddProjectMarker2(0, true, item.pos, item.rgnend, item.name, item.index, item.color)
        else
            reaper.AddProjectMarker2(0, false, item.pos, 0, item.name, item.index, item.color)
        end
        -- Verwijder het item uit de onzichtbare items lijst
        for i, inv_item in ipairs(invisible_items) do
            if inv_item.index == item.index and inv_item.isRegion == item.isRegion and inv_item.project_key == get_project_key() then
                table.remove(invisible_items, i)
                break
            end
        end
    else
        reaper.DeleteProjectMarker(0, item.index, item.isRegion)
        -- Voeg het item toe aan de onzichtbare items lijst
        table.insert(invisible_items, item)
    end
    reaper.UpdateTimeline()
    save_invisible_items()
    save_visibility_to_project()
end

local function update_all_items_visibility(new_visibility, item_type)
    local visibility_changed = false
    local current_project_key = get_project_key()
    
    for _, item in ipairs(project_items[current_project_key] or {}) do
        if (item_type == "markers" and not item.isRegion) or (item_type == "regions" and item.isRegion) then
            if item.visible ~= new_visibility then
                set_item_visibility(item, new_visibility)
                visibility_changed = true
            end
        end
    end
    
    if visibility_changed then
        reaper.UpdateTimeline()
        save_invisible_items()
        save_visibility_to_project()
    end
end


------------------------------------------------------------------------------------------------
-- FUNTIES OM ITEMS IN TABEL TE BEWERKEN
-- Functie om tijd te formatteren met MBT
local function format_time_and_mbt(seconds)
    local minutes = math.floor(seconds / 60)
    local remaining_seconds = seconds % 60
    local time_str = string.format("%d:%05.2f", minutes, remaining_seconds)
    
    local mbt_str = reaper.format_timestr_pos(seconds, "", 2):match("(%d+%.%d+%.%d+)")
    
    -- Converteer de laatste drie cijfers (ticks) naar twee cijfers
    local measure, beat, ticks = mbt_str:match("(%d+)%.(%d+)%.(%d%d%d)")
    if measure and beat and ticks then
        ticks = math.floor(tonumber(ticks) / 10)
        mbt_str = string.format("%s.%s.%02d", measure, beat, ticks)
    end
    
    return time_str .. " (" .. mbt_str .. ")"
end

local function mbt_to_seconds(mbt_string)
    local measure, beat, ticks = mbt_string:match("(%d+)%.(%d+)%.(%d+)")
    if measure and beat and ticks then
        measure = tonumber(measure)
        beat = tonumber(beat)
        ticks = tonumber(ticks)

        -- Converteer ticks van twee naar drie cijfers
        ticks = ticks * 10

        -- Converteer MBT naar een tijdnotatie die REAPER begrijpt
        local time_str = string.format("%d.%d.%03d", measure, beat, ticks)
        
        -- Gebruik REAPER's ingebouwde functie om deze notatie om te zetten naar seconden
        return reaper.parse_timestr_pos(time_str, 2)
    end
    return nil
end

-- Functie om tijd te formatteren en te bewerken
local function edit_time(ctx, item, is_end_time)
    local time = is_end_time and item.rgnend or item.pos
    local time_str = format_time_and_mbt(time)
    local label = is_end_time and "End##" or "Time##"
    local edit_key = is_end_time and "editing_end_time" or "editing_time"
    local edited_times_key = is_end_time and edited_end_times or edited_times
    
    if _G[edit_key] == item.index then
        local current_mbt = edited_times_key[item.index] or reaper.format_timestr_pos(time, "", 2):match("(%d+%.%d+%.%d+)")
        -- Converteer de laatste drie cijfers (ticks) naar twee cijfers voor weergave
        local measure, beat, ticks = current_mbt:match("(%d+)%.(%d+)%.(%d%d%d)")
        if measure and beat and ticks then
            ticks = math.floor(tonumber(ticks) / 10)
            current_mbt = string.format("%s.%s.%02d", measure, beat, ticks)
        end
        
        local changed, new_time_str = reaper.ImGui_InputText(ctx, label .. item.index, current_mbt, reaper.ImGui_InputTextFlags_AutoSelectAll() | reaper.ImGui_InputTextFlags_EnterReturnsTrue())
        
        if changed then
            edited_times_key[item.index] = new_time_str
        end

        if reaper.ImGui_IsItemDeactivatedAfterEdit(ctx) or (changed and reaper.ImGui_IsKeyPressed(ctx, reaper.ImGui_Key_Enter())) then
            local new_time = mbt_to_seconds(edited_times_key[item.index])
            if new_time then
                if is_end_time then
                    item.rgnend = new_time
                    reaper.SetProjectMarker3(0, item.index, true, item.pos, new_time, item.name, item.color)
                else
                    item.pos = new_time
                    reaper.SetProjectMarker3(0, item.index, item.isRegion, new_time, item.rgnend or 0, item.name, item.color)
                end
                reaper.UpdateTimeline()
                reaper.UpdateArrange()
                reaper.Undo_OnStateChange("Update " .. (is_end_time and "region end" or "marker/region start") .. " position")
            end
            _G[edit_key] = nil
            edited_times_key[item.index] = nil
        end
        
        if reaper.ImGui_IsKeyPressed(ctx, reaper.ImGui_Key_Escape()) then
            _G[edit_key] = nil
            edited_times_key[item.index] = nil
        end
    else
        if reaper.ImGui_Selectable(ctx, time_str, false, reaper.ImGui_SelectableFlags_AllowDoubleClick()) then
            if reaper.ImGui_IsMouseDoubleClicked(ctx, 0) then
                _G[edit_key] = item.index
            end
        end
    end
end

-- Functie om een item te verwijderen
local function delete_item(item)
    if item.visible then
        reaper.DeleteProjectMarker(0, item.index, item.isRegion)
        reaper.UpdateTimeline()
    end
    local project_key = get_project_key()
    for i, list_item in ipairs(project_items[project_key]) do
        if list_item.index == item.index and list_item.isRegion == item.isRegion then
            table.remove(project_items[project_key], i)
            break
        end
    end
    for i, inv_item in ipairs(invisible_items) do
        if inv_item.index == item.index and inv_item.isRegion == item.isRegion and inv_item.project_key == project_key then
            table.remove(invisible_items, i)
            break
        end
    end
    save_invisible_items()
end

-- Hulpfunctie om onzichtbare items bij te werken
local function update_invisible_item(item, old_id, new_id)
    local current_project_key = get_project_key()
    
    -- Update in project_items
    for _, proj_item in ipairs(project_items[current_project_key]) do
        if proj_item.index == old_id and proj_item.isRegion == item.isRegion then
            proj_item.index = new_id
            break
        end
    end

    -- Update in invisible_items
    for _, inv_item in ipairs(invisible_items) do
        if inv_item.index == old_id and inv_item.isRegion == item.isRegion and inv_item.project_key == current_project_key then
            inv_item.index = new_id
            break
        end
    end
end

-- funtie voor het aanpassen van de ID van een item (en kleur weergave)
local function display_colored_id(ctx, item, i, items)
    local r, g, b = reaper.ColorFromNative(item.color)
    local color = reaper.ImGui_ColorConvertDouble4ToU32(r/255, g/255, b/255, 0.7)
    
    reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_FrameBg(), color)
    reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_Text(), 0xFFFFFFFF)
    
    reaper.ImGui_PushItemWidth(ctx, 30)
    local display_value = editing_id == i and "" or tostring(item.index)
    local changed, new_id_str = reaper.ImGui_InputText(ctx, "##id" .. i, display_value, reaper.ImGui_InputTextFlags_AutoSelectAll())
    
    if reaper.ImGui_IsItemClicked(ctx) and reaper.ImGui_IsMouseDoubleClicked(ctx, 0) then
        editing_id = i
    end
    
    if editing_id == i then
        if changed then
            local new_id = tonumber(new_id_str)
            if new_id and new_id > 0 then
                local id_exists = false
                for _, other_item in ipairs(items) do
                    if other_item.index == new_id and other_item ~= item then
                        id_exists = true
                        break
                    end
                end
                if not id_exists then
                    local old_id = item.index
                    item.index = new_id

                    if item.visible then
                        -- Voor zichtbare items, update REAPER
                        reaper.DeleteProjectMarker(0, old_id, item.isRegion)
                        if item.isRegion then
                            reaper.AddProjectMarker2(0, true, item.pos, item.rgnend, item.name, new_id, item.color)
                        else
                            reaper.AddProjectMarker2(0, false, item.pos, 0, item.name, new_id, item.color)
                        end
                    else
                        -- Voor onzichtbare items, update alleen de interne datastructuren
                        update_invisible_item(item, old_id, new_id)
                    end

                    reaper.UpdateTimeline()
                    save_invisible_items()
                    save_visibility_to_project()
                end
            end
        end
        if reaper.ImGui_IsItemDeactivatedAfterEdit(ctx) then
            editing_id = nil
        end
    end
    
    reaper.ImGui_PopItemWidth(ctx)
    reaper.ImGui_PopStyleColor(ctx, 2)
end


-- Functie om kleur te bewerken
local function get_sws_colors()
    local colors = {}
    local reaper_resource_path = reaper.GetResourcePath()
    local color_dir = reaper_resource_path .. "/Color/"
  
    local function read_color_file(filename)
        local file_path = color_dir .. filename
        if reaper.file_exists(file_path) then
            for line in io.lines(file_path) do
                local k, v = string.match(line, "^(custcolor%d+)=(%d+)$")
                if k and v then
                    table.insert(colors, tonumber(v))
                end
            end
        end
    end
  
    local i = 0
    local file = reaper.EnumerateFiles(color_dir, i)
    while file do
        if string.match(file, "%.SWSColor$") then
            read_color_file(file)
            break  
        end
        i = i + 1
        file = reaper.EnumerateFiles(color_dir, i)
    end
  
    return colors, #colors > 0 
end

local function edit_color(item, i)
    local sws_colors, has_sws_colors = get_sws_colors()
    if reaper.ImGui_Button(ctx, "Color##" .. tostring(i)) then
        if has_sws_colors then
            if active_color_picker == i then
                active_color_picker = nil
            else
                active_color_picker = i
            end
        else
            local r, g, b = reaper.ColorFromNative(item.color)
            local retval, new_color = reaper.GR_SelectColor(item.color)
            if retval then
                local native_color = new_color|0x1000000
                if item.isRegion then
                    reaper.SetProjectMarker3(0, item.index, true, item.pos, item.rgnend, item.name, native_color)
                else
                    reaper.SetProjectMarker3(0, item.index, false, item.pos, 0, item.name, native_color)
                end
                item.color = native_color
                reaper.UpdateTimeline()
            end
        end
    end

    if active_color_picker == i then
        local pos_x, pos_y = reaper.ImGui_GetItemRectMax(ctx)
        reaper.ImGui_SetNextWindowPos(ctx, pos_x, pos_y, reaper.ImGui_Cond_Always())
        reaper.ImGui_SetNextWindowSize(ctx, 200, 200, reaper.ImGui_Cond_FirstUseEver())
        local window_flags = reaper.ImGui_WindowFlags_NoTitleBar() | reaper.ImGui_WindowFlags_NoMove() | reaper.ImGui_WindowFlags_NoResize() | reaper.ImGui_WindowFlags_AlwaysAutoResize()
        local visible, open = reaper.ImGui_Begin(ctx, "Color Picker##" .. tostring(i), true, window_flags)

        if visible then
            local columns = 8
            local color_count = #sws_colors
            local rows = math.max(1, math.ceil(color_count / columns))

            for row = 1, rows do
                reaper.ImGui_PushID(ctx, row)
                for col = 1, columns do
                    local color_index = (row - 1) * columns + col
                    if color_index <= color_count then
                        local color = sws_colors[color_index]
                        local r, g, b = reaper.ColorFromNative(color)
                        local color_vec4 = reaper.ImGui_ColorConvertDouble4ToU32(r/255, g/255, b/255, 1.0)
                        if reaper.ImGui_ColorButton(ctx, "##SWSColor" .. color_index, color_vec4) then
                            local native_color = reaper.ColorToNative(r, g, b)|0x1000000
                            if item.isRegion then
                                reaper.SetProjectMarker3(0, item.index, true, item.pos, item.rgnend, item.name, native_color)
                            else
                                reaper.SetProjectMarker3(0, item.index, false, item.pos, 0, item.name, native_color)
                            end
                            item.color = native_color
                            reaper.UpdateTimeline()
                            active_color_picker = nil
                        end
                        if col < columns then reaper.ImGui_SameLine(ctx) end
                    end
                end
                reaper.ImGui_PopID(ctx)
            end

            reaper.ImGui_End(ctx)
        end

        if not open then
            active_color_picker = nil
        end
    end
end

-- Hulpfunctie om tijd te parseren (eenvoudige implementatie, kan worden uitgebreid)
local function parse_time(time_str)
    local minutes, seconds = time_str:match("(%d+):([%d%.]+)")
    if minutes and seconds then
        return tonumber(minutes) * 60 + tonumber(seconds)
    end
    return nil
end

------------------------------------------------------------------------------------------------
-- FUNTIES VOOR PRESET SYSTEEM
-- Functie om het pad voor een preset bestand te krijgen
local function get_filename_for_set(action)
    local retval, user_input = reaper.GetUserInputs(action .. " Marker/Region Set", 1, "Filename:", "")
    if retval and user_input ~= "" then
        local filename = user_input
        if not filename:match("%.json$") then
            filename = filename .. ".json"
        end
        if save_preset_globally then
            return global_path .. filename 
        else
            return project_path .. "/" .. filename
        end
    end
    return nil
end

-- Functie om preset bestanden op te halen
local function get_preset_files()
    local presets = {project = {}, global = {}}
    
    local function add_presets_from_path(path, category)
        local i = 0
        local file = reaper.EnumerateFiles(path, i)
        while file do
            if file:match("%.json$") then
                local display_name = file:gsub("%.json$", "")
                local full_path = path .. "/" .. file
                table.insert(presets[category], {name = display_name, path = full_path})
            end
            i = i + 1
            file = reaper.EnumerateFiles(path, i)
        end
    end
    
    add_presets_from_path(project_path, "project")
    add_presets_from_path(global_path, "global")
    return presets
end

-- Functie om een marker/region set op te slaan
local function save_marker_region_set()
    local filename = get_filename_for_set("Save")
    if filename then
        local prefix = save_preset_globally and "g_" or "p_"
        local full_path = filename:gsub("([^\\/]+)$", prefix .. "%1")

        local data = {markers = {}, regions = {}}
        local current_project_key = get_project_key()
        local items = project_items[current_project_key] or {}
        
        for _, item in ipairs(items) do
            local entry = {
                name = item.name,
                pos = item.pos,
                visible = item.visible,
                color = item.color,
                index = item.index
            }
            if item.isRegion then
                entry.endPos = item.rgnend
                table.insert(data.regions, entry)
            else
                table.insert(data.markers, entry)
            end
        end

        if #data.markers > 0 or #data.regions > 0 then
            local file, err = io.open(full_path, "w")
            if file then
                file:write(json.encode(data))
                file:close()
                reaper.ShowConsoleMsg("Preset saved successfully.\n")
            else
                reaper.ShowConsoleMsg("Error opening file for writing: " .. tostring(err) .. "\n")
            end
        else
            reaper.ShowConsoleMsg("No items to Save.\n")
        end
    else
        reaper.ShowConsoleMsg("Save canceled or no filename specified.\n")
    end
end

-- Functie om een marker/region set te laden
local function load_marker_region_set(filepath)
    local file = io.open(filepath, "r")
    if file then
        local content = file:read("*all")
        file:close()
        local success, decoded = pcall(json.decode, content)
        if success then
            reaper.Undo_BeginBlock()
            
            -- Wis alle bestaande markers en regions
            local current_project_key = get_project_key()
            local items_to_delete = {}
            for _, item in ipairs(project_items[current_project_key] or {}) do
                table.insert(items_to_delete, item)
            end
            for _, item in ipairs(items_to_delete) do
                delete_item(item)
            end
            
            -- Wis alle interne datastructuren
            project_items[current_project_key] = {}
            invisible_items = {}
            
            -- Laad de nieuwe markers en regions uit de preset
            if decoded.markers then
                for _, marker in ipairs(decoded.markers) do
                    local new_marker = {
                        name = marker.name,
                        pos = marker.pos,
                        visible = marker.visible,
                        color = marker.color,
                        index = marker.index,
                        isRegion = false,
                        project_key = current_project_key
                    }
                    if marker.visible then
                        reaper.AddProjectMarker2(0, false, marker.pos, 0, marker.name, marker.index, marker.color)
                    else
                        table.insert(invisible_items, new_marker)
                    end
                    table.insert(project_items[current_project_key], new_marker)
                end
            end
           
            if decoded.regions then
                for _, region in ipairs(decoded.regions) do
                    local endPos = region.endPos or region.pos
                    local new_region = {
                        name = region.name,
                        pos = region.pos,
                        rgnend = endPos,
                        visible = region.visible,
                        color = region.color,
                        index = region.index,
                        isRegion = true,
                        project_key = current_project_key
                    }
                    if region.visible then
                        reaper.AddProjectMarker2(0, true, region.pos, endPos, region.name, region.index, region.color)
                    else
                        table.insert(invisible_items, new_region)
                    end
                    table.insert(project_items[current_project_key], new_region)
                end
            end
           
            reaper.UpdateTimeline()
            save_invisible_items()
            save_visibility_to_project()
            reaper.Undo_EndBlock("Load Marker/Region Set", -1)
        else
            reaper.ShowMessageBox("Error decoding JSON file.", "Error", 0)
        end
    else
        reaper.ShowMessageBox("Cannot open file: " .. filepath, "Error", 0)
    end
end
----------------------------------------------------------------------------------------------
-- FUNTIES VOOR CONVERSIE MARKERS EN REGIONS

-- Hulpfunctie om de volgende zichtbare marker te vinden
local function find_next_visible_marker(items, start_pos)
    for _, item in ipairs(items) do
        if not item.isRegion and item.visible and item.pos > start_pos then
            return item.pos
        end
    end
    return reaper.GetProjectLength()
end

-- Hulpfunctie om de volgende beschikbare index te vinden
local function get_next_available_index(items, is_region)
    local max_index = 0
    for _, item in ipairs(items) do
        if item.visible and item.isRegion == is_region and item.index > max_index then
            max_index = item.index
        end
    end
    return max_index + 1
end

local function toggle_marker_region(item, items)
    if item.isRegion then
        -- Converteer regio naar marker
        reaper.DeleteProjectMarker(0, item.index, true)
        local new_index = get_next_available_index(items, false)
        reaper.AddProjectMarker2(0, false, item.pos, 0, item.name, new_index, item.color)
        item.isRegion = false
        item.rgnend = nil
        item.index = new_index
    else
        -- Converteer marker naar regio
        reaper.DeleteProjectMarker(0, item.index, false)
        local rgnend = find_next_visible_marker(items, item.pos)
        local new_index = get_next_available_index(items, true)
        reaper.AddProjectMarker2(0, true, item.pos, rgnend, item.name, new_index, item.color)
        item.isRegion = true
        item.rgnend = rgnend
        item.index = new_index
    end
    reaper.UpdateTimeline()
end

----------------------------------------------------------------------------------------------
-- FUNTIES VOOR TIMELINE MINIMAP
local function snap_to_grid(time)
    local _, division = reaper.GetSetProjectGrid(0, false)
    return math.floor(time / (division * 2) + 0.5) * (division * 2)
end

local function draw_timeline_minimap(ctx, items)
    local width, height = reaper.ImGui_GetContentRegionAvail(ctx)
    local project_length = reaper.GetProjectLength(0)
    local draw_list = reaper.ImGui_GetWindowDrawList(ctx)
    local pos_x, pos_y = reaper.ImGui_GetCursorScreenPos(ctx)
    local right_margin = 0
    local time_label_height = 13
    reaper.ImGui_DrawList_AddRectFilled(draw_list, pos_x, pos_y, pos_x + width - right_margin, pos_y + height - time_label_height, 0x202020FF)
    
    local num_markers = 8
    for i = 0, num_markers do
        local proportion = i / num_markers
        local time = proportion * project_length
        local beat_time = reaper.TimeMap2_timeToQN(0, time)
        local nearest_measure = math.floor(beat_time / 4) * 4 -- Assuming 4 beats per measure
        local nearest_measure_time = reaper.TimeMap2_QNToTime(0, nearest_measure)
        local x = pos_x + (nearest_measure_time / project_length) * (width - right_margin)
        local mbt = reaper.format_timestr_pos(nearest_measure_time, "", 1):match("(%d+%.1)") -- Only measure and beat without ticks
        reaper.ImGui_DrawList_AddLine(draw_list, x, pos_y, x, pos_y + height - time_label_height, 0x808080FF, 1)
        reaper.ImGui_DrawList_AddText(draw_list, x, pos_y + height - time_label_height, 0xFFFFFFFF, mbt)
    end
    
    for _, item in ipairs(items) do
        if item.visible then
            local x = pos_x + ((item.pos / project_length) * (width - right_margin))
            local r, g, b = reaper.ColorFromNative(item.color)
            local color = reaper.ImGui_ColorConvertDouble4ToU32(r/255, g/255, b/255, 1)

            if item.isRegion then
                local end_x = pos_x + ((item.rgnend / project_length) * (width - right_margin))
                reaper.ImGui_DrawList_AddRectFilled(draw_list, x, pos_y, end_x, pos_y + height - time_label_height, color)
            else
                reaper.ImGui_DrawList_AddLine(draw_list, x, pos_y, x, pos_y + height - time_label_height, color, 2)
            end
        end
    end
    
    local cursor_pos = reaper.GetCursorPosition()
    local cursor_x = pos_x + ((cursor_pos / project_length) * (width - right_margin))
    reaper.ImGui_DrawList_AddLine(draw_list, cursor_x, pos_y, cursor_x, pos_y + height - time_label_height, 0xFFFFFFFF, 2)
    
    reaper.ImGui_InvisibleButton(ctx, "timeline", width, height)
    if reaper.ImGui_IsItemHovered(ctx) then
        if reaper.ImGui_IsMouseClicked(ctx, 0) then
            local mouse_x = reaper.ImGui_GetMousePos(ctx)
            local new_pos = ((mouse_x - pos_x) / (width - right_margin)) * project_length
            local snapped_pos = snap_to_grid(new_pos)
            reaper.SetEditCurPos(snapped_pos, true, true)
        end
    end
end

-----------------------------------------------------------------------------------------
-- FUNCTIES VOOR KNOPPEN EN CHECKBOXEN 
function IsRegionMarkerManagerOpen()
    local title = "Region/Marker Manager"
    local hwnd = reaper.JS_Window_Find(title, true)
    return hwnd ~= nil
  end

function AreGridlinesShown()
    return reaper.GetToggleCommandStateEx(0, 42328) == 1
end

function IsRegionPlaylistVisible()
    return reaper.GetToggleCommandStateEx(0, reaper.NamedCommandLookup("_S&M_SHOW_RGN_PLAYLIST")) == 1
  end

function DrawShowRgnPlaylistCheckbox()
    local is_visible = IsRegionPlaylistVisible()
    local rv, new_checkbox = reaper.ImGui_Checkbox(ctx, "Region Playlist", is_visible)
    if rv and new_checkbox ~= is_visible then
      reaper.Main_OnCommand(reaper.NamedCommandLookup("_S&M_SHOW_RGN_PLAYLIST"), 0)
    end
  end

  local function IsRenderMatrixVisible()
    local title = "Region Render Matrix"
    local hwnd = reaper.JS_Window_Find(title, true)
    return hwnd ~= nil
end

local function DrawRenderMatrixCheckbox()
    local is_rrm_open = IsRenderMatrixVisible()
    local changed_rrm, new_show_region_matrix_visible = reaper.ImGui_Checkbox(ctx, "Region Matrix", is_rrm_open)
    if changed_rrm then
        reaper.Main_OnCommand(41888, 0)
        is_rrm_open = IsRenderMatrixVisible()
    end
end


-- Functie om autocolor voor zowel markers als regions in te stellen
local function sync_autocolor_state()
    local marker_state = reaper.GetToggleCommandState(reaper.NamedCommandLookup("_S&MAUTOCOLOR_MKR_ENABLE"))
    local region_state = reaper.GetToggleCommandState(reaper.NamedCommandLookup("_S&MAUTOCOLOR_RGN_ENABLE"))
    
    -- Bepaal de gewenste staat (aan als een van beide aan is, anders uit)
    local desired_state = (marker_state == 1 or region_state == 1) and 1 or 0
    
    -- Zet beide acties naar de gewenste staat
    if marker_state ~= desired_state then
        reaper.Main_OnCommand(reaper.NamedCommandLookup("_S&MAUTOCOLOR_MKR_ENABLE"), 0)
    end
    if region_state ~= desired_state then
        reaper.Main_OnCommand(reaper.NamedCommandLookup("_S&MAUTOCOLOR_RGN_ENABLE"), 0)
    end
    
    return desired_state == 1
end

-- Hernummer funtie 
local function renumber_items(is_region)
    local current_project_key = get_project_key()
    local items = project_items[current_project_key] or {}
    
    -- Stap 1: Sla de huidige zichtbaarheidsstatus op en maak alles zichtbaar
    local visibility_status = {}
    for _, item in ipairs(items) do
        if item.isRegion == is_region then
            visibility_status[item.index] = item.visible
            if not item.visible then
                set_item_visibility(item, true)
            end
        end
    end
    
    -- Stap 2: Voer de REAPER-actie uit om alle (nu zichtbare) items te hernummeren
    local action_id = is_region and "_SWSMARKERLIST8" or "_SWSMARKERLIST7"
    reaper.Main_OnCommand(reaper.NamedCommandLookup(action_id), 0)
    
    -- Stap 3: Update onze interne datastructuren met de nieuwe nummering
    local _, num_markers, num_regions = reaper.CountProjectMarkers(0)
    local new_items = {}
    for i = 0, num_markers + num_regions - 1 do
        local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
        if retval ~= 0 and isrgn == is_region then
            local item = {
                name = name,
                pos = pos,
                rgnend = rgnend,
                color = color,
                index = markrgnindexnumber,
                isRegion = isrgn,
                visible = true,  -- Tijdelijk alles zichtbaar
                project_key = current_project_key
            }
            table.insert(new_items, item)
        end
    end
    
    -- Stap 4: Herstel de oorspronkelijke zichtbaarheidsstatus
    for _, item in ipairs(new_items) do
        local original_visibility = visibility_status[item.index]
        if original_visibility == false then
            set_item_visibility(item, false)
        end
    end
    
    -- Update de project_items tabel
    project_items[current_project_key] = new_items
    
    -- Update de timeline en sla de wijzigingen op
    reaper.UpdateTimeline()
    save_invisible_items()
    save_visibility_to_project()
end

local function move_markers_and_regions_to_cursor()
    local cursor_pos = reaper.GetCursorPosition()
    local current_project_key = get_project_key()
    local all_items = project_items[current_project_key] or {}
    
    if #all_items > 0 then
        local offset = cursor_pos - all_items[1].pos
        
        reaper.Undo_BeginBlock()
        
        for _, item in ipairs(all_items) do
            local new_pos = item.pos + offset
            if item.isRegion then
                local new_end = item.rgnend + offset
                if item.visible then
                    reaper.SetProjectMarker(item.index, true, new_pos, new_end, item.name, item.color)
                else
                    item.pos = new_pos
                    item.rgnend = new_end
                end
            else
                if item.visible then
                    reaper.SetProjectMarker(item.index, false, new_pos, 0, item.name, item.color)
                else
                    item.pos = new_pos
                end
            end
        end
        
        reaper.Undo_EndBlock("Move all markers and regions to cursor", -1)
        reaper.UpdateTimeline()
        
        save_invisible_items()
        save_visibility_to_project()
    end
end

local function run_script(script_name)
    local script_path = reaper.GetResourcePath() .. "/Scripts/TK Scripts/TK SMART/" .. script_name
    if reaper.file_exists(script_path) then
        dofile(script_path)
    else
        reaper.ShowMessageBox("Script not found: " .. script_name, "Error", 0)
    end
end

local function add_marker_buttons(ctx)
    if reaper.ImGui_Button(ctx, "Marker@start sel items", 120) then
        run_script("TK_marker at start items on the track.lua")
    end
    reaper.ImGui_SameLine(ctx)
    if reaper.ImGui_Button(ctx, "Marker@mid sel items", 120) then
        run_script("TK_marker at middle items on the track.lua")
    end
end
------------------------------------------------------------------------------------------------
-- REGION VOORTGANGSBAR
local function lighten_color(r, g, b, factor)
    return math.min(r + (255 - r) * factor, 255),
           math.min(g + (255 - g) * factor, 255),
           math.min(b + (255 - b) * factor, 255)
end


local function get_region_under_play_cursor()
    local play_pos = reaper.GetPlayPosition()
    local num_markers = reaper.CountProjectMarkers(0)
    for i = 0, num_markers - 1 do
        local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
        if isrgn and pos <= play_pos and rgnend >= play_pos then
            return {start = pos, ending = rgnend, name = name, color = color, index = markrgnindexnumber}
        end
    end
    return nil
end


local function format_time(seconds)
    local minutes = math.floor(seconds / 60)
    local remaining_seconds = seconds % 60
    return string.format("%d:%05.2f", minutes, remaining_seconds)
end

local function draw_region_progress(ctx, region, window_width)
    if not region then return end

    local play_pos = reaper.GetPlayPosition()
    local progress = (play_pos - region.start) / (region.ending - region.start)
    progress = math.max(0, math.min(1, progress))

    local bar_width = window_width - 16
    local bar_height = 14
    local pos_x, pos_y = reaper.ImGui_GetCursorScreenPos(ctx)

    local draw_list = reaper.ImGui_GetWindowDrawList(ctx)
    local r, g, b = reaper.ColorFromNative(region.color)
    local region_color = reaper.ImGui_ColorConvertDouble4ToU32(r/255, g/255, b/255, 1)
    
    local lr, lg, lb = lighten_color(r, g, b, 0.5) -- factor om lichter te maken
    local light_region_color = reaper.ImGui_ColorConvertDouble4ToU32(lr/255, lg/255, lb/255, 1)

    reaper.ImGui_DrawList_AddRectFilled(draw_list, pos_x, pos_y, pos_x + bar_width, pos_y + bar_height, region_color)
    reaper.ImGui_DrawList_AddRectFilled(draw_list, pos_x, pos_y, pos_x + bar_width * progress, pos_y + bar_height, light_region_color)

    local elapsed_time = play_pos - region.start
    local remaining_time = region.ending - play_pos
    local total_time = region.ending - region.start
    local time_text = string.format("%d: %s - %s / %s / %s", region.index or 0, region.name or "", format_time(elapsed_time), format_time(remaining_time), format_time(total_time))
    
    local text_width = reaper.ImGui_CalcTextSize(ctx, time_text)
    local text_x = pos_x + (bar_width - text_width) / 2
    
    reaper.ImGui_DrawList_AddText(draw_list, text_x, pos_y + 1, 0x000000FF, time_text)

    reaper.ImGui_SetCursorPosY(ctx, reaper.ImGui_GetCursorPosY(ctx) + bar_height + 5)
    reaper.ImGui_Dummy(ctx, 0, 0)
end
------------------------------------------------------------------------------------------------
-- TESTGEBIED!!!! --
-- Funtie om markers en regions te selecteren
function update_reaper_selection(item, selected)
    local flags = 0
    if selected then
        flags = 1  -- 1 is de vlag voor selectie in REAPER
    end
    reaper.SetProjectMarker4(0, item.index, item.isRegion, item.pos, item.rgnend or 0, item.name, item.color, flags)
    reaper.UpdateTimeline()
end

-- Functie om Naamveld leeg te maken
function clear_item_name(item)
    item.name = ""
    item_names[item.index .. (item.isRegion and "R" or "M")] = ""
    local flags = 1  
    reaper.SetProjectMarker4(0, item.index, item.isRegion, item.pos, item.rgnend or 0, "", item.color, flags)
    reaper.UpdateTimeline()
end


-------------------------------------------------------------------------------------------------
-- MAIN FUNCTION
local function main()
    -- Initialisatie
    ensure_json_file_exists()
    load_invisible_items()
    load_logo() 
    local items = get_markers_and_regions()
    
    
    -- GUI OPMAAK
    local dark_gray = 0x303030FF
    local hover_gray = 0x606060FF
    local active_gray = 0x404040FF
    local button_width = 75
    reaper.ImGui_PushFont(ctx, arial_font)
    reaper.ImGui_PushStyleVar(ctx, reaper.ImGui_StyleVar_FrameRounding(), 3)
    reaper.ImGui_PushStyleVar(ctx, reaper.ImGui_StyleVar_WindowRounding(), 7) 

    reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_WindowBg(), 0x000000FF)
    reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_Text(), 0xFFFFFFFF)
    reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_Button(), dark_gray)
    reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_ButtonHovered(), hover_gray)
    reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_ButtonActive(), active_gray)
    reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_Tab(), dark_gray)
    reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_TabHovered(), hover_gray)
    reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_FrameBg(), dark_gray)
    reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_FrameBgHovered(), hover_gray)
    reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_FrameBgActive(), active_gray)
    
    local min_width = 520
    local transparency = 0.75
    reaper.ImGui_SetNextWindowSizeConstraints(ctx, min_width, 300, 16384, 16384)
    reaper.ImGui_SetNextWindowBgAlpha(ctx, transparency)
    
    local window_flags = reaper.ImGui_WindowFlags_NoTitleBar() | 
                         reaper.ImGui_WindowFlags_NoCollapse() | 
                         reaper.ImGui_WindowFlags_NoScrollbar() |
                         reaper.ImGui_WindowFlags_NoScrollWithMouse()
    
    local visible, open = reaper.ImGui_Begin(ctx, 'TK SMART', true, window_flags)
    if visible then

        -- PRESET FUNCTIONALITEIT
        local presets = get_preset_files()
        local selected_preset = {category = nil, index = nil}

        if reaper.ImGui_Button(ctx, "Save Preset", button_width) then
            save_marker_region_set()
        end
        
        reaper.ImGui_SameLine(ctx)
        reaper.ImGui_SetNextItemWidth(ctx, 158)
        if reaper.ImGui_BeginCombo(ctx, "##Presets", selected_preset.index and (selected_preset.category .. ": " .. presets[selected_preset.category][selected_preset.index].name) or "Select preset") then
            if #presets.project > 0 then
                reaper.ImGui_TextDisabled(ctx, "Project Presets:")
                for i, preset in ipairs(presets.project) do
                    local is_selected = (selected_preset.category == "project" and selected_preset.index == i)
                    if reaper.ImGui_Selectable(ctx, preset.name, is_selected) then
                        if reaper.ImGui_IsKeyDown(ctx, reaper.ImGui_Mod_Alt()) then
                            -- Delete preset
                            table.remove(presets.project, i)
                            os.remove(preset.path)
                            selected_preset = {category = nil, index = nil}
                        else
                            -- Load preset
                            selected_preset = {category = "project", index = i}
                            load_marker_region_set(preset.path)
                        end
                    end
                    if is_selected then
                        reaper.ImGui_SetItemDefaultFocus(ctx)
                    end
                end
            end
       
            if #presets.global > 0 then
                reaper.ImGui_TextDisabled(ctx, "Global Presets:")
                for i, preset in ipairs(presets.global) do
                    local is_selected = (selected_preset.category == "global" and selected_preset.index == i)
                    if reaper.ImGui_Selectable(ctx, preset.name, is_selected) then
                        if reaper.ImGui_IsKeyDown(ctx, reaper.ImGui_Mod_Alt()) then
                            -- Delete preset
                            table.remove(presets.global, i)
                            os.remove(preset.path)
                            selected_preset = {category = nil, index = nil}
                        else
                            -- Load preset
                            selected_preset = {category = "global", index = i}
                            load_marker_region_set(preset.path)
                        end
                    end
                    if is_selected then
                        reaper.ImGui_SetItemDefaultFocus(ctx)
                    end
                end
            end
            
            reaper.ImGui_EndCombo(ctx)
        end
    
        reaper.ImGui_SameLine(ctx)
        local changed, new_save_preset_globally = reaper.ImGui_Checkbox(ctx, "Global preset", save_preset_globally)
        if changed then
            save_preset_globally = new_save_preset_globally
            reaper.SetExtState("TK_SMART", "save_preset_globally", tostring(save_preset_globally), true)
        end

        -- laat logo zien
        reaper.ImGui_SameLine(ctx)
        display_logo(ctx)
        

        -- QUIT BUTTON
        local window_width = reaper.ImGui_GetWindowWidth(ctx)
        reaper.ImGui_SameLine(ctx, window_width - 47 - 8)
        reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_Button(), 0xFF0000FF)
        reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_ButtonHovered(), 0xFF5555FF)
        reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_ButtonActive(), 0xFF0000FF)
        if reaper.ImGui_Button(ctx, 'Quit', 47) then
            open = false
        end
        reaper.ImGui_PopStyleColor(ctx, 3)

        -- AD MARKER AND REGION BUTTON
        if reaper.ImGui_Button(ctx, "+Marker", button_width) then
            local cursor_pos = reaper.GetCursorPosition()
            reaper.AddProjectMarker(0, false, cursor_pos, 0, "", -1)
            items = get_markers_and_regions() -- Gebruik de bestaande functie van TK_SMART
        end
        reaper.ImGui_SameLine(ctx)
        
        if reaper.ImGui_Button(ctx, "+Region", button_width) then
            local start_time, end_time = reaper.GetSet_LoopTimeRange(false, false, 0, 0, false)
            
            if end_time <= start_time then
                start_time = reaper.GetCursorPosition()
                end_time = start_time + 1
            end
            reaper.AddProjectMarker(0, true, start_time, end_time, "", -1)
            items = get_markers_and_regions() -- Gebruik de bestaande functie van TK_SMART
        end
        reaper.ImGui_SameLine(ctx)

        -- RENUMBER MARKERS AND REGIONS BUTTONS
        if reaper.ImGui_Button(ctx, "Renumber M", button_width) then
            reaper.Undo_BeginBlock()
            renumber_items(false)  -- false voor markers
            reaper.Undo_EndBlock("Renumber Markers", -1)
            items = get_markers_and_regions()  -- Update de items na hernummering
        end
        
        reaper.ImGui_SameLine(ctx)
        if reaper.ImGui_Button(ctx, "Renumber R", button_width) then
            reaper.Undo_BeginBlock()
            renumber_items(true)  -- true voor regions
            reaper.Undo_EndBlock("Renumber Regions", -1)
            items = get_markers_and_regions()  -- Update de items na hernummering
        end

        -- BROWSER BUTTON
        reaper.ImGui_SameLine(ctx)
        local window_width = reaper.ImGui_GetWindowWidth(ctx)
        reaper.ImGui_SetCursorPosX(ctx, window_width - 47 - 8)
        reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_Button(), 0x0080FFFF)
        reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_ButtonHovered(), 0x0099FFFF)
        reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_ButtonActive(), 0x0080FFFF)
        if reaper.ImGui_Button(ctx, "Browser", 47) then
        if show_browser then
        SHOW_BROWSER = false
        show_browser = false
        else
        SHOW_BROWSER = true
        local browser_path = reaper.GetResourcePath() .. "/Scripts/TK Scripts/TK SMART/TK_marker_Region_Action_Browser.lua"
        dofile(browser_path)
        show_browser = true
        end
    end
        reaper.ImGui_PopStyleColor(ctx, 3)

        -- TIMELINE
        reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_Header(), 0x00000000)
        reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_HeaderHovered(), 0x00000000)
        reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_HeaderActive(), 0x00000000)

        if reaper.ImGui_Selectable(ctx, "Project Timeline", false, reaper.ImGui_SelectableFlags_AllowDoubleClick()) then
            if reaper.ImGui_IsMouseDoubleClicked(ctx, 0) then
                show_minimap = not show_minimap
            end
        end

        reaper.ImGui_PopStyleColor(ctx, 3)
        
        if show_minimap then
            local timeline_height = 50
            reaper.ImGui_BeginChild(ctx, "Timeline", 0, timeline_height, reaper.ImGui_WindowFlags_None())
            draw_timeline_minimap(ctx, items)
            reaper.ImGui_EndChild(ctx)
        end

        -- MARKER TABEL
        if reaper.ImGui_BeginTabBar(ctx, "MarkerRegionTabs") then
            local available_height = calculate_available_height(ctx)
            
            if reaper.ImGui_BeginTabItem(ctx, "Markers") then
                if reaper.ImGui_BeginChild(ctx, "MarkersTableChild", 0, available_height) then
                    if reaper.ImGui_BeginTable(ctx, "MarkersTable", 8, reaper.ImGui_TableFlags_Borders()) then
                    reaper.ImGui_TableSetupColumn(ctx, "##Visible", reaper.ImGui_TableColumnFlags_WidthFixed(), 35)
                    reaper.ImGui_TableSetupColumn(ctx, "ID", reaper.ImGui_TableColumnFlags_WidthFixed(), 30)
                    reaper.ImGui_TableSetupColumn(ctx, "Name", reaper.ImGui_TableColumnFlags_WidthStretch())
                    reaper.ImGui_TableSetupColumn(ctx, "Time", reaper.ImGui_TableColumnFlags_WidthFixed(), 75)
                    reaper.ImGui_TableSetupColumn(ctx, "Color", reaper.ImGui_TableColumnFlags_WidthFixed(), 35)
                    reaper.ImGui_TableSetupColumn(ctx, "Convert", reaper.ImGui_TableColumnFlags_WidthFixed(), 55)
                    reaper.ImGui_TableSetupColumn(ctx, "Del", reaper.ImGui_TableColumnFlags_WidthFixed(), 15)
                    reaper.ImGui_TableSetupColumn(ctx, "Select", reaper.ImGui_TableColumnFlags_WidthFixed(), 35)
                    reaper.ImGui_TableHeadersRow(ctx)
                    
                    -- klik functie om alle markers te tonen of te verbergen
                    reaper.ImGui_TableSetColumnIndex(ctx, 0)
                    local x, y = reaper.ImGui_GetCursorScreenPos(ctx)
                    local draw_list = reaper.ImGui_GetWindowDrawList(ctx)
                    local text_width = reaper.ImGui_CalcTextSize(ctx, "Visible")
                    local cell_width = 35 -- De breedte die we eerder hebben ingesteld
                    local cell_height = reaper.ImGui_GetTextLineHeight(ctx)
                    
                    reaper.ImGui_DrawList_AddText(draw_list, x + (cell_width - text_width) / 2, y, 0xFFFFFFFF, "Visible")
                    
                    if reaper.ImGui_InvisibleButton(ctx, "##VisibleHeaderMarkers", cell_width, cell_height) then
                        local all_markers_visible = true
                        for _, item in ipairs(project_items[get_project_key()] or {}) do
                            if not item.isRegion then
                                all_markers_visible = all_markers_visible and item.visible
                            end
                        end
                        update_all_items_visibility(not all_markers_visible, "markers")
                    end
                    -- --

                    for i, item in ipairs(items) do
                        if not item.isRegion then
                            reaper.ImGui_TableNextRow(ctx)
                            
                            reaper.ImGui_TableSetColumnIndex(ctx, 0) -- Visible checbox
                            local changed, new_visible = reaper.ImGui_Checkbox(ctx, "##visible" .. i, item.visible)
                            if changed then
                                set_item_visibility(item, new_visible)
                            end

                            reaper.ImGui_TableSetColumnIndex(ctx, 1) -- ID
                            display_colored_id(ctx, item, i, items)
                            
                            
                            reaper.ImGui_TableSetColumnIndex(ctx, 2) -- Name

                            -- naam veld leeg maken
                            if reaper.ImGui_Button(ctx, "X##clear_name" .. i) then
                                clear_item_name(item)
                            end
                            reaper.ImGui_SameLine(ctx)

                            -- naamweergave en bewerking
                            local display_name = item.name ~= "" and item.name or ""
                            if editing_name == i then
                                local changed, new_name = reaper.ImGui_InputText(ctx, "##name" .. i, item.name)
                                if changed then
                                    item.name = new_name
                                    if item.visible then
                                        reaper.SetProjectMarker3(0, item.index, item.isRegion, item.pos, item.rgnend or 0, new_name, item.color)
                                        reaper.UpdateTimeline()
                                    end
                                end
                                if reaper.ImGui_IsItemDeactivatedAfterEdit(ctx) then
                                    editing_name = nil
                                end
                            else
                                if reaper.ImGui_Selectable(ctx, display_name, false, reaper.ImGui_SelectableFlags_AllowDoubleClick()) then
                                    if reaper.ImGui_IsMouseDoubleClicked(ctx, 0) then
                                        editing_name = i
                                    end
                                end
                            end

                        
                            reaper.ImGui_TableSetColumnIndex(ctx, 3) -- Time
                            edit_time(ctx, item, false)
                            reaper.ImGui_TableSetColumnIndex(ctx, 4) -- Color
                            edit_color(item, i)

                            reaper.ImGui_TableSetColumnIndex(ctx, 5) -- Convert
                            if reaper.ImGui_Button(ctx, "To Region##" .. i) then
                            toggle_marker_region(item, items)
                            end

                            reaper.ImGui_TableSetColumnIndex(ctx, 6) -- Delete button
                            if reaper.ImGui_Button(ctx, "X##" .. i) then
                            delete_item(item)
                            end

                            reaper.ImGui_TableSetColumnIndex(ctx, 7) -- Select checkbox
                            local item_key = item.index .. (item.isRegion and "R" or "M")
                            local is_selected = selected_items[item_key] or false
                            local changed, new_selected = reaper.ImGui_Checkbox(ctx, "##select" .. i, is_selected)
                            if changed then
                                selected_items[item_key] = new_selected
                                update_reaper_selection(item, new_selected)
                            end


                        end
                    end
                    reaper.ImGui_EndTable(ctx)
                end
            end
                reaper.ImGui_EndChild(ctx)
                reaper.ImGui_EndTabItem(ctx)
            end
            
            -- REGION TABEL
            if reaper.ImGui_BeginTabItem(ctx, "Regions") then
                if reaper.ImGui_BeginChild(ctx, "RegionsTableChild", 0, available_height) then
                    if reaper.ImGui_BeginTable(ctx, "RegionsTable", 8, reaper.ImGui_TableFlags_Borders()) then
                    reaper.ImGui_TableSetupColumn(ctx, "##Visible", reaper.ImGui_TableColumnFlags_WidthFixed(), 35)
                    reaper.ImGui_TableSetupColumn(ctx, "ID", reaper.ImGui_TableColumnFlags_WidthFixed(), 30)
                    reaper.ImGui_TableSetupColumn(ctx, "Name", reaper.ImGui_TableColumnFlags_WidthStretch())
                    reaper.ImGui_TableSetupColumn(ctx, "Start", reaper.ImGui_TableColumnFlags_WidthFixed(), 75)
                    reaper.ImGui_TableSetupColumn(ctx, "End", reaper.ImGui_TableColumnFlags_WidthFixed(), 75)
                    reaper.ImGui_TableSetupColumn(ctx, "Color", reaper.ImGui_TableColumnFlags_WidthFixed(), 35)
                    reaper.ImGui_TableSetupColumn(ctx, "Convert", reaper.ImGui_TableColumnFlags_WidthFixed(), 55)
                    reaper.ImGui_TableSetupColumn(ctx, "Del", reaper.ImGui_TableColumnFlags_WidthFixed(), 15)
                    reaper.ImGui_TableHeadersRow(ctx)
                    
                    -- klik funtie om alle regions te verbergen of te zien
                    reaper.ImGui_TableSetColumnIndex(ctx, 0)
                    local x, y = reaper.ImGui_GetCursorScreenPos(ctx)
                    local draw_list = reaper.ImGui_GetWindowDrawList(ctx)
                    local text_width = reaper.ImGui_CalcTextSize(ctx, "Visible")
                    local cell_width = 35 -- De breedte die we eerder hebben ingesteld
                    local cell_height = reaper.ImGui_GetTextLineHeight(ctx)
                    
                    reaper.ImGui_DrawList_AddText(draw_list, x + (cell_width - text_width) / 2, y, 0xFFFFFFFF, "Visible")
                    
                    if reaper.ImGui_InvisibleButton(ctx, "##VisibleHeaderRegions", cell_width, cell_height) then
                        local all_regions_visible = true
                        for _, item in ipairs(project_items[get_project_key()] or {}) do
                            if item.isRegion then
                                all_regions_visible = all_regions_visible and item.visible
                            end
                        end
                        update_all_items_visibility(not all_regions_visible, "regions")
                    end
                    -- --

                    for i, item in ipairs(items) do
                        if item.isRegion then
                            reaper.ImGui_TableNextRow(ctx)
                            
                            reaper.ImGui_TableSetColumnIndex(ctx, 0) -- Visible checbox
                            local changed, new_visible = reaper.ImGui_Checkbox(ctx, "##visible" .. i, item.visible)
                            if changed then
                                set_item_visibility(item, new_visible)
                            end

                            reaper.ImGui_TableSetColumnIndex(ctx, 1) -- ID
                            display_colored_id(ctx, item, i, items)

                            reaper.ImGui_TableSetColumnIndex(ctx, 2) -- Name

                            -- naam veld leeg maken
                            if reaper.ImGui_Button(ctx, "X##clear_name" .. i) then
                                clear_item_name(item)
                            end
                            reaper.ImGui_SameLine(ctx)

                            -- naamweergave en bewerking
                            local display_name = item.name ~= "" and item.name or ""
                            if editing_name == i then
                                local changed, new_name = reaper.ImGui_InputText(ctx, "##name" .. i, item.name)
                                if changed then
                                    item.name = new_name
                                    if item.visible then
                                        reaper.SetProjectMarker3(0, item.index, item.isRegion, item.pos, item.rgnend or 0, new_name, item.color)
                                        reaper.UpdateTimeline()
                                    end
                                end
                                if reaper.ImGui_IsItemDeactivatedAfterEdit(ctx) then
                                    editing_name = nil
                                end
                            else
                                if reaper.ImGui_Selectable(ctx, display_name, false, reaper.ImGui_SelectableFlags_AllowDoubleClick()) then
                                    if reaper.ImGui_IsMouseDoubleClicked(ctx, 0) then
                                        editing_name = i
                                    end
                                end
                            end

                            reaper.ImGui_TableSetColumnIndex(ctx, 3) -- Start time
                            edit_time(ctx, item, false)

                            reaper.ImGui_TableSetColumnIndex(ctx, 4) -- End time
                            edit_time(ctx, item, true)

                            reaper.ImGui_TableSetColumnIndex(ctx, 5) -- Color
                            edit_color(item, i)

                            reaper.ImGui_TableSetColumnIndex(ctx, 6) -- Convert
                            if reaper.ImGui_Button(ctx, "To Marker##" .. i) then
                            toggle_marker_region(item, items)
                            end

                            reaper.ImGui_TableSetColumnIndex(ctx, 7) -- Del
                            if reaper.ImGui_Button(ctx, "X##" .. i) then
                                delete_item(item)
                            end
                        end
                    end
                    reaper.ImGui_EndTable(ctx)
                end
            end
                reaper.ImGui_EndChild(ctx)
                reaper.ImGui_EndTabItem(ctx)
            end

            -- TAB3: ACTIONS TAB
            if reaper.ImGui_BeginTabItem(ctx, "Actions") then
                if reaper.ImGui_BeginChild(ctx, "ActionsChild", 0, available_height) then
                reaper.ImGui_BeginGroup(ctx)
                local button_width = 120
                if reaper.ImGui_Button(ctx, "Smart Action Browser", button_width) then
                    if show_action_browser then
                        SHOW_ACTION_BROWSER = false
                        show_action_browser = false
                    else
                        SHOW_ACTION_BROWSER = true
                        local action_browser_path = reaper.GetResourcePath() .. "/Scripts/TK Scripts/TK SMART/TK_Action_Browser.lua"
                        dofile(action_browser_path)
                        show_action_browser = true
                    end
                end
                reaper.ImGui_SameLine(ctx)
                
                local smart_marker_state = reaper.GetToggleCommandState(reaper.NamedCommandLookup("_SWSMA_TOGGLE"))
                local button_text = smart_marker_state == 1 and "Smart Marker: ON" or "Smart Marker: OFF"
                local button_color = smart_marker_state == 1 and 0x00AA00FF or 0xAA0000FF -- Groen als aan, rood als uit

                reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_Button(), button_color)
                if reaper.ImGui_Button(ctx, button_text, button_width) then
                    local command_id = reaper.NamedCommandLookup("_SWSMA_TOGGLE")
                    reaper.Main_OnCommand(command_id, 0)
                    smart_marker_state = reaper.GetToggleCommandState(command_id)
                end
                reaper.ImGui_PopStyleColor(ctx)
                reaper.ImGui_SameLine(ctx)

                if reaper.ImGui_Button(ctx, "Autocolor Window", button_width) then
                    reaper.Main_OnCommand(reaper.NamedCommandLookup("_SWSAUTOCOLOR_OPEN"), 0)
                end
                reaper.ImGui_SameLine(ctx)
                
                local autocolor_enabled = sync_autocolor_state()
                local button_text = autocolor_enabled and "Autocolor: ON" or "Autocolor: OFF"
                local button_color = autocolor_enabled and 0x00AA00FF or 0xAA0000FF

                reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_Button(), button_color)
                if reaper.ImGui_Button(ctx, button_text, button_width) then
                    autocolor_enabled = not autocolor_enabled
                    local desired_state = autocolor_enabled and 1 or 0
                    
                   
                    if reaper.GetToggleCommandState(reaper.NamedCommandLookup("_S&MAUTOCOLOR_MKR_ENABLE")) ~= desired_state then
                        reaper.Main_OnCommand(reaper.NamedCommandLookup("_S&MAUTOCOLOR_MKR_ENABLE"), 0)
                    end
                    if reaper.GetToggleCommandState(reaper.NamedCommandLookup("_S&MAUTOCOLOR_RGN_ENABLE")) ~= desired_state then
                        reaper.Main_OnCommand(reaper.NamedCommandLookup("_S&MAUTOCOLOR_RGN_ENABLE"), 0)
                    end
                end
                reaper.ImGui_PopStyleColor(ctx)
                
                if reaper.ImGui_Button(ctx, "Dummy", button_width) then
                    -- Actie voor Knop 4
                end
                reaper.ImGui_SameLine(ctx)
                
                if reaper.ImGui_Button(ctx, "Move All to cursor", button_width) then
                    move_markers_and_regions_to_cursor()
                    items = get_markers_and_regions() -- Update de items na verplaatsing
                end
                reaper.ImGui_SameLine(ctx)
                
                if reaper.ImGui_Button(ctx, "Dummy", button_width) then
                    -- Actie voor Knop 3
                end
                reaper.ImGui_SameLine(ctx)
                
                if reaper.ImGui_Button(ctx, "Dummy", button_width) then
                    -- Actie voor Knop 4
                end
                
                local ddp_action_id = reaper.NamedCommandLookup("__DDP_MARKER_EDITOR")
                if ddp_action_id ~= 0 then
                    if reaper.ImGui_Button(ctx, "DDP Manager", button_width) then
                        reaper.Main_OnCommand(ddp_action_id, 0)
                    end
                else
                    reaper.ImGui_Text(ctx, "DDP Marker Editor not present.")
                    if reaper.ImGui_Button(ctx, "Download DDP Ext", button_width) then
                        reaper.CF_ShellExecute("https://stash.reaper.fm/34295/reaper_ddp_edit_R1.zip")
                    end
                end
                reaper.ImGui_SameLine(ctx)
                add_marker_buttons(ctx)
                reaper.ImGui_SameLine(ctx)
                
                reaper.ImGui_PushStyleColor(ctx, reaper.ImGui_Col_Button(), 0xFF8C00FF) -- Oranje kleur
                if reaper.ImGui_Button(ctx, "Learn Browser", button_width) then
                    if show_weblink_browser then
                        SHOW_WEBLINK_BROWSER = false
                        show_weblink_browser = false
                    else
                        SHOW_WEBLINK_BROWSER = true
                        local weblink_browser_path = reaper.GetResourcePath() .. "/Scripts/TK Scripts/TK SMART/TK_Learn_Browser(MR).lua"
                        dofile(weblink_browser_path)
                        show_weblink_browser = true
                    end
                end
                reaper.ImGui_PopStyleColor(ctx)


                reaper.ImGui_EndGroup(ctx)
            end
                reaper.ImGui_EndChild(ctx)
                reaper.ImGui_EndTabItem(ctx)
            end

        -- EINDE TAB    
            reaper.ImGui_EndTabBar(ctx)
        end

------------------------------------------------------------------------------
-- BOTTEM SECTION        
        reaper.ImGui_Separator(ctx)
        local button_width = 70

        local are_gridlines_shown = AreGridlinesShown()
        local changed, new_show_as_gridlines = reaper.ImGui_Checkbox(ctx, "Show Gridlines", are_gridlines_shown)
        if changed and new_show_as_gridlines ~= are_gridlines_shown then
            reaper.Main_OnCommand(42328, 0) 
        end
        reaper.ImGui_SameLine(ctx)
        local is_rmm_open = IsRegionMarkerManagerOpen()
        local changed_rmm, new_show_region_marker_manager = reaper.ImGui_Checkbox(ctx, "R/M Manager", is_rmm_open)
        if changed_rmm and new_show_region_marker_manager ~= is_rmm_open then
            reaper.Main_OnCommand(40326, 0) 
        end
        reaper.ImGui_SameLine(ctx)
        DrawShowRgnPlaylistCheckbox()
        
        reaper.ImGui_SameLine(ctx)
        DrawRenderMatrixCheckbox()
   
        reaper.ImGui_SameLine(ctx)

        local window_width = reaper.ImGui_GetWindowWidth(ctx)
        reaper.ImGui_SameLine(ctx, window_width - 47 - 61)
        if reaper.ImGui_Button(ctx, "DEL M", 47) then
            reaper.Main_OnCommand(reaper.NamedCommandLookup("_SWSMARKERLIST9"), 0)
          
        end
        local window_width = reaper.ImGui_GetWindowWidth(ctx)
        reaper.ImGui_SameLine(ctx, window_width - 47 - 8)
        if reaper.ImGui_Button(ctx, "DEL R", 47) then
            reaper.Main_OnCommand(reaper.NamedCommandLookup("_SWSMARKERLIST10"), 0)
       
        end
        reaper.ImGui_Dummy(ctx, 0, 3) 
        local current_region = get_region_under_play_cursor()
        draw_region_progress(ctx, current_region, window_width)
        reaper.ImGui_Dummy(ctx, 0, 0)
----------------------------------------------------------------------------------
-- SCRIPT EINDE
    -- stijlen afsluiten    
    reaper.ImGui_PopStyleColor(ctx, 10)
    reaper.ImGui_PopStyleVar(ctx, 2)
    reaper.ImGui_PopFont(ctx)
    
    -- sluit script met esc key
    if check_esc_key() then open = false end
    reaper.ImGui_End(ctx)
    end   
    
    if open then
        reaper.defer(main)
    else
        save_invisible_items()
        save_visibility_to_project()
    end
end
reaper.defer(main)